## gradual type的实际用途

- 对于动态类型的语言，每个变量在运行时可以有任何类型的值
- 这虽然增加了语言的表达力，从而使得prototyping变得容易，但是过于自由，容易出现一些问题，例如
```python
def fun(ls, n):
    for i in range(n):
        ls[i] += 1
```
- 在这个程序中，只是“约定”了`ls`和`n`的类型应该是数字列表和数字（这个其实也有问题，应该从duck typing的角度描述类型），我们其实可以传给函数`fun`以任意类型的参数
- 如何添加额外的约束？
- 第一种方案：擦除语义。在代码中添加类型信息，并在静态阶段利用这些类型信息进行类型提示，但不影响运行时的任何行为。
- 第二种方案：合约语义，也叫深度语义。在代码中添加类型信息作为约束，在运行时做精细的检查来符合这些约束。
- 第三种方案：短暂语义，也叫浅层语义。在代码中添加类型信息作为约束，在运行时只做最粗略的检查来尽量符合这些约束。


## 类型系统的选择
- 是不是可以用鸭子类型系统代替常规的值类型系统
- blame是运行时产生的，blame label的本质是cast的静态位置，和Python自带的异常处理机制是不同的